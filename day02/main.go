package main

import "fmt"

const input = `DLUUULUDLRDDLLLUDULLULLRUURURLUULDUUUDLDDRUDLUULLRLDDURURDDRDRDLDURRURDLDUURULDDULDRDDLDLDLRDRUURLDLUDDDURULRLLLLRLULLUDRDLDUURDURULULULRLULLLULURLRDRDDDDDDDLRLULUULLULURLLDLRLUDULLDLLURUDDLDULDLULDDRLRLRDDLRURLLLURRLDURRDLLUUUUDRURUULRLDRRULLRUDLDRLUDRDRDRRDDURURRDRDRUDURDLUDRUDLRRULDLRDDRURDDUUDLDRDULDDRRURLLULRDRURLRLDLLLUULUUDLUDLDRRRRDUURULDUDUDRLDLLULLLRDDDDDLRDDLLUULLRRRDURLRURDURURLUDRRLRURDRDRRRRULUDLDRDULULRUDULLLUDRRLRLURDDURULDUUDULLURUULRDRDULRUUUDURURDDRRUDURRLRDRULRUUU
LDRURRUUUULDRDDDLLULDRUDDRLLDLDRDLRUDDDLDDULULULLRULDUDRRDLRUURURDRURURDLLRUURDUUDRLDURDRDLRRURURDUUUURUURRLLLDRDUURRRRURULUUUDLUDDRUURRLDULRDULRRRRUDURRLURULRURRDRDLLDRRDUDRDURLDDRURULDRURUDDURDLLLUURRLDRULLURDRDRLDRRURRLRRRDDDDLUDLUDLLDURDURRDUDDLUDLRULRRRDRDDLUDRDURDRDDUURDULRRULDLDLLUDRDDUDUULUDURDRLDURLRRDLDDLURUDRLDUURLLRLUDLLRLDDUDLLLRRRLDLUULLUDRUUDRLDUUUDUURLRDDDDRRDRLDDRDLUDRULDDDRDUULLUUUUULDULRLLLRLLDULRDUDDRDDLRRLRDDULLDURRRURDDUDUDDRLURRLUUUULLDRDULUUDRDULDLLUDLURDLLURRDLUULURRULRLURRRRRUURDDURLRLLDDLRRDUUURDRDUDRDDDLLDDRDRRRLURRDUULULULULRRURDDLDDLLLRUDDDDDDLLLRDULURULLRLRDRR
DDRLLLDLRRURRDLDDRUURRURRLRRRRUURUURDLURRRDDLRUDRURLUURLLRRLRLURLURURDULLLLDLRURULUUDURRLULRDRDRRDDLLULRLUDLUUUDRLLRRURRLDULDDLRRLUUUUDDLRLDRLRRDRDLDDURDDRDDLDLURLRRRDDUDLLRLRLURRRRULLULLLLDRLDULDLLDULRLDRDLDDRRDDDDRUDRLLURULRLDDLLRRURURDDRLLLULLULDDRDLDDDLRLLDRLDRUURRULURDDRLULLDUURRULURUUDULLRUDDRRLLDLLRDRUDDDDLLLDDDLLUUUULLDUUURULRUUDUUUDDLDURLDRDRRLLUDULDLUDRLLLDRRRULUUDDURUDRLUDDRRLLDUDUURDDRURLUURDURURURRUUDUDDLLLDRRRURURRURDLRULLDUDRLRLLRUDRUDLR
RRRDRLRURLRRLUURDRLDUURURLRDRRUDLLUUDURULLUURDLLDRRLURRUDUUDRRURLRRDULLDDLRRRUDUUDUUDLDDDLUUDLDULDDULLDUUUUDDUUDUDULLDDURRDLRRUDUDLRDUULDULRURRRLDLLURUDLDDDRRLRDURDLRRLLLRUDLUDRLLLRLLRRURUDLUDURLDRLRUDLRUULDRULLRLDRDRRLDDDURRRUDDDUDRRDRLDDRDRLLRLLRDLRDUDURURRLLULRDRLRDDRUULRDDRLULDLULURDLRUDRRDDDLDULULRDDRUDRLRDDRLDRDDRRRDUURDRLLDDUULRLLLULLDRDUDRRLUUURLDULUUURULLRLUDLDDLRRDLLRDDLRDRUUDURDDLLLDUUULUUDLULDUDULDRLRUDDURLDDRRRDLURRLLRRRUDDLDDRURDUULRUURDRRURURRRUUDUDULUDLUDLLLUUUULRLLRRRRDUDRRDRUDURLUDDLDRDLDDRULLRRULDURUL
DLLLRDDURDULRRLULURRDULDLUDLURDDURRLLRRLLULRDLDRDULRLLRDRUUULURRRLLRLDDDRDRRULDRRLLLLDLUULRRRURDDRULLULDDDLULRLRRRUDRURULUDDRULDUDRLDRRLURULRUULLLRUURDURLLULUURUULUUDLUDLRRULLLRRLRURDRRURDRULRURRUDUDDDRDDULDLURUDRDURLDLDLUDURLLRUULLURLDDDURDULRLUUUDLLRRLLUURRDUUDUUDUURURDRRRRRRRRRUDULDLULURUDUURDDULDUDDRDDRDRLRUUUUDLDLRDUURRLRUUDDDDURLRRULURDUUDLUUDUUURUUDRURDRDDDDULRLLRURLRLRDDLRUULLULULRRURURDDUULRDRRDRDLRDRRLDUDDULLDRUDDRRRD
`

type pos struct {
	x int
	y int
}

func main() {
	keycode1 := part1(input)

	for _, r := range keycode1 {
		fmt.Printf("%c", r)
	}

	println()

	keycode2 := part2(input)

	for _, r := range keycode2 {
		fmt.Printf("%c", r)
	}
}

func part1(in string) []rune {
	keypad := [][]rune{}

	col1 := []rune{'1', '4', '7'}
	col2 := []rune{'2', '5', '8'}
	col3 := []rune{'3', '6', '9'}

	keypad = append(keypad, col1)
	keypad = append(keypad, col2)
	keypad = append(keypad, col3)

	p := pos{1, 1}

	var keycode []rune
	for _, c := range in {
		pNext := p

		switch c {
		case 'U':
			if p.y > 0 {
				pNext.y = p.y - 1
			}
		case 'R':
			if p.x < 2 {
				pNext.x = p.x + 1
			}
		case 'D':
			if p.y < 2 {
				pNext.y = p.y + 1
			}
		case 'L':
			if p.x > 0 {
				pNext.x = p.x - 1
			}
		case '\n':
			nexCode := keypad[pNext.x][pNext.y]
			keycode = append(keycode, nexCode)
		default:
			continue
		}

		//fmt.Println(p, fmt.Sprintf("%c", keypad[p.x][p.y]), fmt.Sprintf("%c", c), pNext, fmt.Sprintf("%c", keypad[pNext.x][pNext.y]))

		p = pNext
	}

	return keycode
}

func part2(in string) []rune {

	// Setup keypad
	keypad := [][]rune{}
	col1 := []rune{' ', ' ', '5', ' ', ' '}
	col2 := []rune{' ', '2', '6', 'A', ' '}
	col3 := []rune{'1', '3', '7', 'B', 'D'}
	col4 := []rune{' ', '4', '8', 'C', ' '}
	col5 := []rune{' ', ' ', '9', ' ', ' '}

	keypad = append(keypad, col1)
	keypad = append(keypad, col2)
	keypad = append(keypad, col3)
	keypad = append(keypad, col4)
	keypad = append(keypad, col5)

	p := pos{0, 2}

	var keycode []rune
	for _, c := range in {
		pNext := p

		switch c {
		case 'U':
			if p.y > 0 {
				pNext.y = p.y - 1
			}
		case 'R':
			if p.x < 4 {
				pNext.x = p.x + 1
			}
		case 'D':
			if p.y < 4 {
				pNext.y = p.y + 1
			}
		case 'L':
			if p.x > 0 {
				pNext.x = p.x - 1
			}
		case '\n':
			nexCode := keypad[pNext.x][pNext.y]
			keycode = append(keycode, nexCode)
		default:
			continue
		}

		if keypad[pNext.x][pNext.y] == ' ' {
			continue
		}

		//fmt.Println(p, fmt.Sprintf("%c", keypad[p.x][p.y]), fmt.Sprintf("%c", c), pNext, fmt.Sprintf("%c", keypad[pNext.x][pNext.y]))

		p = pNext
	}

	return keycode
}
